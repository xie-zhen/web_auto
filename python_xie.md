#### 前言

1. 标识符&关键字
   - 标识符就是起名，要有意义
   - 关键字在pycharm里有特殊颜色（shenlans）
2. 输出

- python中的输出语句为print()
- 格式化输出多个内容，包括字符串和值
- 换行输出（print（）输出自带换行）







### 1、基础部分





#### 1.1、常见的三个错误

- 函数名写错了，名字没有定义
- 多行print写在一起
- 缩进错误

#### 1.2、单行注释

- 作用
  - 用来标注某些代码的含义，防止过后看不懂
  - #号和中文注释之间，应该由有一个空格
- 写在哪里？
  - 希望解释的代码上方（#号和代码最左对齐）
  - 希望解释的代码后面（至少两个空格）
- 快捷键
  - Ctrl键+/
  - 使用快捷键可以快速的让某些代码不执行，如果需要执行，再次取消即可

#### 1.3、多行注释

- 作用   用来标注某些代码的含义
- 怎么写？
  - 三引号（pycharm会自动出来6个，并且光标在中间，一对三引号中间都是注释，不影响程序的执行）

#### 1.4、算数运算符

- 加   +
- 减   -
- 乘   *
- 除   /
- 取整除   //
- 取余数   %
- 幂   **
- 注意点
  - 字符串 + 字符串
    - 拼接字符串
  - 字符串 *  5
    - 字符串复制五份进行拼接
    - “*” * 5     =     “\*\*\*\*\*”
  - python2和python3的除法的注意点
    - python3更像数学（自动执行小数的处理）

#### 1.5、算数运算符优先级

1. 有括号先括号
2. 先乘除后加减
3. 同级别的从左网友
4. 级别
   1. **
   2. \* / // %
   3. \+ \-

#### 1.6、比较关系运算符

- == 检查两个操作数的值是否相等，如果是，则条件成立，返回True
- !=  /  >  /  <  /  >=  /  <=

#### 1.7、逻辑关系运算符

- and   or  not  

- not x   如果x 为True，返回False

  ![bool真假](C:\Users\xie\Desktop\bool真假.png)

  ![](C:\Users\xie\Desktop\bool002.png)

#### 1.8、变量

- 变量的声明
  - 变量名 = 值
  - 原理：在内存中开辟一块控件，存值。让变量名，引用这块内存的内存地址
- 等号（=）
  - 用来赋值的
  - 右侧 值
  - 左侧 变量名
- 变量为什么叫“变”量
  - 已经在内存中声明过得变量，多次赋值，会以最后一次为准。
- 所有的python乃至（基本上所有的编程语言），都是等号右侧先执行。

#### 1.9、python数据类型★★★

```python
# 使用type函数查看一个变量类型化
type(name)
```



Python3 中有六个标准的数据类型：

- Number（数字）
  - 整数  int
  - 浮点数   float
  - 布尔型   bool
    - 真 True  数学运算是表示  1
    - 假  False  数学运算是表示  0
  - 复数型  complex
    - 复数由实数部分和虚数部分构成，实部a和虚部b都是浮点型
- String（字符串）
- List（列表）
- Tuple（元组）
- Set（集合）
- Dictionary（字典）

Python3 的六个标准数据类型中：

- **不可变数据（3 个）：**Number（数字）、String（字符串）、Tuple（元组）；
- **可变数据（3 个）：**List（列表）、Dictionary（字典）、Set（集）

#### 1.10、python关键字  ★★★

```python
import keyword
keyword.kwlist
#  要熟记常用关键字
import/from/False/True/not/in/if/is/None
and/or/in/for/pass/while/else/as/return
class/lambda/elif/finally/global/continue/break
with/try/del/def/
```

#### 1.11、标识符

- 标识符就是程序员定义的**变量名、函数名**。名字要有见名知义的效果

- 规范

  - 抛去中文问题
  - 字母数字下划线，字母区分大小写
  - 不能数字开头
  - 不能有特殊符号
  - 不能与关键字重名

  ```python
  # python 中如果变量名需要由两个或者多个单词组成时，命名规范
  1、单词与单词之间用下划线连接
  2、不要写拼音、不要写中文、全部小写
  ```

#### 1.12、驼峰命名法★★★★

- 小驼峰命名法
  - 第一个单词以小写字母开始，后续单词的首字母大写
    - firstName  /  lastName
- 大驼峰命名法
  - 每一个单词的首字母都大写
    - MyName  /  FirstName  /  LastName

#### 1.13、格式化输出

- % 被称为***格式化操作符***，专门用于处理字符串中的格式
  - 包含 % 号的字符串，被称为**格式化字符串**
  - % 和不同的字符连用，不同类型的数据需要使用不同格式的字符串
- 语法格式如下

```python
print("格式化字符串" % 变量1)
print("格式化字符串" % (变量1，变量2···))

# 多个需要用逗号隔开，外面有个括号
# 根据变量名的顺序，会按照占位符的顺序进行替换

%s 字符串
%d 整数
%f 浮点数（小数）
%06d  整数，不足6位，用0补齐
%.2f  小数，保留两位小数

# %s / %d / %f ，叫做占位符
```

#### 1.14、输入

- 函数  input("提示信息")

- 作用/效果

  - 等待用户输入，知道输入完成，后面的代码才会运行

- ***接受到用户输入的都是字符串***

- 如何将字符串转换成整数或者浮点数

  ```python
  int(input("please input your information "))
  float(input("请输入内容"))
  ```

### 2、Part2

#### 2.1、条件语句

- if /elif / else 

  - 只要这三者，写在同一个缩进中，就是表示平级的关系，具体根据条件跳转到对应的代码

- not 作用

  - 针对某一个布尔类型的值，进行取反
  - 如果需求只是希望 “没有票”的时候输出
  - 那么可以写成

  ```python
  if not has_ticket:
      print("没有票")
  ```


#### 2.2、赋值运算符

- python提供的一种，简写的赋值方式
- i += 1   就是  i = i + 1
- i -= 1    就是  i = i -1

#### 2.3、while 循环

- 重复执行某一段特定代码
- 语法：
  - 预制条件(i)
  - while 针对 i 的条件
  - 缩进循环体
  - 在循环体中记得处理预置的条件 i 

```python
i = 0 
while i < 100:
    做事情（100遍）
    i += 1
```

- 死循环
  - 忘记在循环体内部修改循环的判断条件，导致循环持续执行，程序无法终止！
  - 如果是while True内部有break的情况下，不算做死循环

#### 2.4、break 和 continue

- break 
  - 无论之后的什么代码，只要遇到，直接跳出循环
  - break在嵌套循环中，只对最近的一层起作用
- continue
  - 无论之后的是什么代码，只要遇到，会直接跳出while处，继续循环

#### 2.5、字符串中的转译字符

| 转译字符 | 描述                                                   |
| -------- | ------------------------------------------------------ |
| \        | 反斜杠符号，转义字符                                   |
| \t       | 制表符，协助在输出文本时，垂直方向保持对齐，但不会换行 |
| \"       | 双引号，                                               |
| \'       | 单引号                                                 |
| \n       | 换行                                                   |
| \r       | 回车                                                   |

#### 2.6、列表

1. list（列表）是python中使用最频繁的数据类型
2. 专门用于存储一串数据，存储的数据称为元素
3. 列表用 [] 定义，元素之间用逗号分隔
4. 列表是有顺序的，可以通过下标、索引获取元素的内容

##### 2.6.1、列表的常用操作

| 序号 | 分类 | 关键字 / 函数 / 方法    | 说明                                                 |
| ---- | ---- | ----------------------- | ---------------------------------------------------- |
| 1    | 增加 | 列表.append(数据)       | 在末尾追加数据                                       |
|      |      | 列表.insert(索引, 数据) | 在指定位置插入数据(位置前有空元素会补位)             |
|      |      | 列表.extend(Iterable)   | 将可迭代对象中 的元素 追加到列表                     |
| 2    | 删除 | del 列表[索引]          | 删除指定索引的数据                                   |
|      |      | 列表.remove(数据)       | 删除第一个出现的指定数据                             |
|      |      | 列表.pop()              | 删除末尾数据,返回被删除的元素                        |
|      |      | 列表.pop(索引)          | 删除指定索引数据                                     |
|      |      | 列表.clear              | 清空列表                                             |
| 3    | 修改 | 列表[索引] = 数据       | 修改指定索引的数据，数据不存在会报错                 |
| 4    | 查询 | 列表[索引]              | 根据索引取值，索引不存在会报错                       |
|      |      | 列表.index(数据)        | 根据值查询索引，返回首次出现时的索引，没有查到会报错 |
|      |      | 列表.count(数据)        | 数据在列表中出现的次数                               |
|      |      | len(列表)               | 列表长度                                             |
|      |      | if 数据 in 列表:        | 检查列表中是否包含某元素                             |
| 5    | 排序 | 列表.sort()             | 升序排序                                             |
|      |      | 列表.sort(reverse=True) | 降序排序                                             |
|      |      | 列表.reverse()          | 逆序、反转                                           |

```python
#  有列表list_a = [1,2,3],如果想生成一个新的列表list_b,下列做法正确的是（C）
A：list_b = list_a.append(4)  #  通过.append追加数据没有返回值，只能打印输出list_a
B: list_b = list_a.extend([4])
C: list_b = list_a + [4]  
```

##### 2.6.2、循环遍历_列表

- 定义：
  - 遍历就是从头到尾依次从列表中取出每一个元素，并执行相同的操作
- 遍历实现方式：
  - while   需要是使用 i 条件
  - for 不一定需要使用 i 条件，大部分不需要

```python
#  列表生成式
List Comprehensions 列表生成式是Python内置的非常简单却强大的可以用来创建list的生成式。

简单的数值范围的list可以使用以下方式生成：
>>> list(range(1, 11))
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

稍微复杂的可以利用list生成式：
>>> [x * x for x in range(1, 11)]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

循环后面还可以加上if判断，例如仅筛选出偶数的平方：
>>>[x*x for x in range(1, 11) if x%2 == 0]
[4, 16, 36, 64, 100]

使用两层循环可以生成全排列：
>>> [m + n for m in 'ABC' for n in 'XYZ']
['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']
```

- 列表的嵌套

  - 列表中的元素，如果有一个是另外一个列表，那么我们叫左列表的嵌套

- 办公室案例

  一个学校，有3个办公室，现在有8位老师等待工位的分配，请编写程序: 1> 完成随机的分配 2> 获取办公室信息 (每个办公室中的人数，及分别是谁) 

```python 

```

```python
# 练习
>>>[[“张三”, 18], ["李四", 19], ["王五", 20]]
# 输出
>>>”我们班一个有 x 个人“
>>>”其中，张三的年龄为18岁，李四的年龄为19岁。。。。。。，希望他们早日毕业。找个好工作，早日20k。“



```

#### 2.7、元祖

- 区别：不能修改

        ▲因为不能修改，只能查找和遍历

- 定义

  - 元祖用（）定义
  - 用于存储一串数据，元素之间使用逗号隔开
  - 元祖的索引从0开始
  - 元祖中只包含一个元素时，需要在后面添加逗号
    - info_tuple = (50,)

- **元祖的常用操作**

| 序号 | 分类 | 关键字 / 函数 / 方法 | 说明                                                         |
| ---- | ---- | -------------------- | ------------------------------------------------------------ |
| 1    | 查询 | 元组[索引]           | 根据索引取值，索引不存在会报错                               |
|      |      | 元组.index(数据)     | 根据值查询索引，返回首次出现时的索引，没有查到会报错         |
|      |      | 元组.count(数据)     | 数据在元组中出现的次数                                       |
|      |      | len(元祖)            | 元组长度                                                     |
|      |      | if 数据 in 元组:     | 检查元组中是否包含某元素。。。返回bool类型，判断元素是否在元祖中 |
| 2    | 遍历 | for 元素 in 元组:    | 取出元组中的每个元素                                         |

- 应用场景

```python
#  格式化字符串，百分号后边的字符串其实是一个元祖
info = ("zhangsan", 18)
print("%s的年龄是%d" % info)

#  让列表不可以被修改，保护数据安全
>>元祖和列表之间的转换
>>>使用"tuple"函数把列表转换乘元祖
list1 = [10,12]
tuple1 = tuple(list1)

>>>使用"list"函数把元祖转换成列表
list1 = list(tuple)

#  元祖可以用来快速赋值，并且可以作为交换变量的值，作为自动组包的默认类型
a,b = 1,2(赋值)
a,b = b,a (交换值)  #  先自动组包再自动解包

```

#### 2.8、字典

##### 2.8.1字典定义（dictionary）

- 字典是处列表之外 python之中最灵活的数据类型
- 字典可以用类存储多个数据
  - 通常用于存储描述一个物体的相关信息
- 字典用 ｛｝ 定义
- 字典使用键值对存储数据，键值对之间用 **逗号** 分隔
  - 键 key 是唯一的  >>>  键只能是数字、字符串或元祖
  - 值 value   >>> 值可以是任何数据类型
  - key  和  value 之间用**冒号**分隔
  - 字典没有索引，是无序的

##### 2.8.2、字典的常用操作

| 序号 | 分类 | 关键字 / 函数 / 方法      | 说明                                                      |
| ---- | ---- | ------------------------- | --------------------------------------------------------- |
| 1    | 增加 | **字典[键] = 数据**       | 键不存在，会添加键值对；键存在，会修改键值对的值          |
| 2    | 删除 | del 字典[键]              | 删除指定的键值对                                          |
|      |      | 字典.pop(键)              | 删除指定键值对,返回被删除的值                             |
|      |      | 字典.clear                | 清空字典                                                  |
| 3    | 修改 | 字典[键] = 数据           | 键不存在，会添加键值对；键存在，会修改键值对的值          |
|      |      | 字典.setdefault(键，数据) | 键值对不存在，添加键值对；存在则不做处理                  |
|      |      | 字典.update(字典2)        | 取出字典2的键值对，键值对不存在，添加键值对；存在则修改值 |
| 4    | 查询 | **字典[键]**              | 根据键取值，键值对不存在会报错                            |
|      |      | 字典.get(键)              | 根据键取值，键值对不存在不会报错                          |
|      |      | 字典.keys()               | 可进行遍历，获取所有键                                    |
|      |      | 字典.values()             | 可进行遍历，获取所有值                                    |
|      |      | 字典.items()              | 可进行遍历，获取所有(键，值)                              |
| 5    | 遍历 | for key in 字典           | 取出元组中的每个元素的 **key**                            |

 ```python
dict1 = {"a":1, "b":2, "c":3}
# 获取所有的键
>>>dict1.keys()

# 取出dict1中 "c" 的值
dict1["c"]		# 根据键取值，键值对不存在，会报错
dict1.get("c")	# 根据键取值，键值对不存在，不会报错
 ```

#### 2.9、字符串

- 单引号和双引号都可以表示字符串。
- 如果字符串中使用到了双引号当作字符，那么使用单引号引起来，不需要考虑转义的问题，，，反之也可以使用
- 字符串也可以进行遍历，遍历的是字符串中的每个字符

#### 2.9.1、 字符串的常用操作

#### 1) 判断

| 方法                   | 说明                                                         |
| ---------------------- | ------------------------------------------------------------ |
| string.isdigit()       | 如果 string 只包含数字则返回 True                            |
| string.isdecimal()     | 如果 string 只包含数字则返回 True                            |
| string.islower()       | 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True |
| string.isupper()       | 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True |
| string.startswith(str) | 检查字符串是否是以 str 开头，是则返回 True                   |
| string.endswith(str)   | 检查字符串是否是以 str 结束，是则返回 True                   |
| string.isalpha()       | 如果 string 至少有一个字符并且所有字符都是字母则返回 True    |

#### 2) 查找和替换

| 方法                                                    | 说明                                                         |
| ------------------------------------------------------- | ------------------------------------------------------------ |
| string.find(str, start=0, end=len(string))              | 检测 str 是否包含在 string 中，如果 start 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回 `-1` |
| string.rfind(str, start=0, end=len(string))             | 类似于 find()，不过是从右边开始查找                          |
| string.index(str, start=0, end=len(string))             | 跟 find() 方法类似，不过如果 str 不在 string 会报错          |
| string.rindex(str, start=0, end=len(string))            | 类似于 index()，不过是从右边开始                             |
| string.replace(old_str, new_str, num=string.count(old)) | 返回一个新字符串，把 string 中的 old_str 替换成 new_str，如果 num 指定，则替换不超过 num 次 |

#### 3) 拆分和连接

| 方法                      | 说明                                                         |
| ------------------------- | ------------------------------------------------------------ |
| string.partition(str)     | 返回元组，把字符串 string 分成一个 3 元素的元组 (str前面, str, str后面) |
| string.rpartition(str)    | 类似于 partition() 方法，不过是从右边开始查找                |
| string.split(str="", num) | 返回列表，以 str 为分隔符拆分 string，如果 num 有指定值，则仅分隔 num + 1 个子字符串，str 默认包含 '\r', '\t', '\n' 和空格 |
| string.splitlines()       | 返回列表，按照行('\r', '\n', '\r\n')分隔                     |
| string1 + string2         | 拼接两个字符串                                               |
| string.join(seq)          | 返回字符串，以 string 作为分隔符，将 seq 中所有的元素（的字符串表示）合并为一个新的字符串 |

#### 4) 大小写转换

| 方法           | 说明                                           |
| -------------- | ---------------------------------------------- |
| string.lower() | 返回新字符串，转换 string 中所有大写字符为小写 |
| string.upper() | 返回新字符串，转换 string 中的小写字母为大写   |

#### 5) 文本对齐

| 方法                 | 说明                                                         |
| -------------------- | ------------------------------------------------------------ |
| string.ljust(width)  | 返回新字符串，基于原字符串左对齐，并使用空格填充至长度 width |
| string.rjust(width)  | 返回新字符串，基于原字符串右对齐，并使用空格填充至长度 width |
| string.center(width) | 返回新字符串，基于原字符串居中，并使用空格填充至长度 width   |

#### 6) 去除空白字符

| 方法            | 说明                                             |
| --------------- | ------------------------------------------------ |
| string.lstrip() | 返回新字符串，截掉 string 左边（开始）的空白字符 |
| string.rstrip() | 返回新字符串，截掉 string 右边（末尾）的空白字符 |
| string.strip()  | 返回新字符串，截掉 string 左右两边的空白字符     |

> 提示：列表除了查询方法和pop方法都没有返回值，字符串所有方法都有返回值

#### 7）案例

```python
# string = "hello world" ,统计每个字符串出现的次数
b = {a:string.count(a) for a in set(string.replace(" ",""))}  #  排除空格的做法
```

```python
"""  
a.如果不是数字：则直接返回“不是数字，请重新输入”
b.判断用户输入是否是数字
如果是数字：则继续判断，输入数字是否是9的倍数
Ⅰ、如果是，返回结果“是”
Ⅱ、否则返回结果是
"""
def main():
    opt = input("请输入内容")   
    if str.isdecimal(opt) :
        a = int(opt)
        if a%9 == 0:
            print("是数字，且是9的倍数")
        else:
            print("是数字，但不是9的倍数")
    else:
        print("不是数字请重新输入")
if __name__ == '__main__':
    main()

```



### 3、切片

- 语法 （适用于字符串、列表、元祖）
  - 字符串[开始索引：结束索引：步长]
  - 元祖[开始索引：结束索引：步长]
  - 列表[开始索引：结束索引：步长]
- 字典不能使用切片
- 开始索引和结束索引是左闭右开（意味着，结束的末尾索引下标为 -1 ，）
- 倒序索引，最右边的索引值是-1，一次递减
- 索引或者步长为负数，表示倒序，倒着往前找

```python
num_str = "0123456789"

# 1. 截取从 2 ~ 5 位置 的字符串
print(num_str[2:6])

# 2. 截取从 2 ~ `末尾` 的字符串
print(num_str[2:])

# 3. 截取从 `开始` ~ 5 位置 的字符串
print(num_str[:6])

# 4. 截取完整的字符串
print(num_str[:])

# 5. 从开始位置，每隔一个字符截取字符串
print(num_str[::2])

# 6. 从索引 1 开始，每隔一个取一个
print(num_str[1::2])

# 倒序切片
# -1 表示倒数第一个字符
print(num_str[-1])

# 7. 截取从 2 ~ `末尾 - 1` 的字符串
print(num_str[2:-1])

# 8. 截取字符串末尾两个字符
print(num_str[-2:])

# 9. 字符串的逆序（面试题）
print(num_str[::-1])
```

### 4、公共语法

**1、python的内置函数**

| 函数      | 描述                 | 备注                        |
| --------- | -------------------- | --------------------------- |
| len(item) | 计算容器中元素个数   |                             |
| del(item) | 删除变量             | del 有两种方式              |
| max(item) | 返回容器中元素最大值 | 如果是字典，只针对 key 比较 |
| min(item) | 返回容器中元素最小值 | 如果是字典，只针对 key 比较 |

- 字符串比较大小
  - "0-9" < "A-Z" < "a-z"
  - 从左往右一位一位进行比较

**2、运算符**

| 运算符       | Python 表达式         | 结果                         | 描述           | 支持的数据类型           |
| ------------ | --------------------- | ---------------------------- | -------------- | ------------------------ |
| +            | [1, 2] + [3, 4]       | [1, 2, 3, 4]                 | 合并           | 字符串、列表、元组       |
| *            | ["Hi!"] * 4           | ['Hi!', 'Hi!', 'Hi!', 'Hi!'] | 重复           | 字符串、列表、元组       |
| in           | 3 in (1, 2, 3)        | True                         | 元素是否存在   | 字符串、列表、元组、字典 |
| not in       | 4 not in (1, 2, 3)    | True                         | 元素是否不存在 | 字符串、列表、元组、字典 |
| > >= == < <= | (1, 2, 3) < (2, 2, 3) | True                         | 元素比较       | 字符串、列表、元组       |

- 列表相加 = 列表1.extend(列表2)
- in 和 not in 被称为成员运算符
- in 对字典操作时，判断的是字典的键

**3、for..else 语法**

- else 什么时候执行
  - 当循环正常结束时，会执行else
  - 如果有break打断，那么不会执行else



```python
students = [
    {"name": "阿土",
     "age": 20,
     "gender": True,
     "height": 1.7,
     "weight": 75.0},
    {"name": "小美",
     "age": 19,
     "gender": False,
     "height": 1.6,
     "weight": 45.0},
]

find_name = "阿土"

for stu_dict in students:

    print(stu_dict)

    # 判断当前遍历的字典中姓名是否为find_name
    if stu_dict["name"] == find_name:
        print("找到了")

        # 如果已经找到，直接退出循环，就不需要再对后续的数据进行比较
        break

else:
    print("没有找到")

print("循环结束")
```

### 5、函数的基本使用

#### 5.1、函数的定义

```python
# 定义函数的格式如下
def 函数名():
    函数封装的代码
    
# 通过函数名（）即可完成对函数的调用，，，函数只有在调用的时候才会执行
def say_hello():
    print("hello")

say_hello() #  完成对函数的调用
```

#### 5.2、断点调试

- pycharm的一个功能
- 在代码和行号之间，使用鼠标点击（打断点）
- 右键运行的时候，选择debug。等待程序“卡”在红点处
  - F8 **Step Over** 可以单步执行代码，会把函数调用看作是一行代码直接执行
  - F7 **Step Into** 可以单步执行代码，如果是函数，会进入函数内部
- console控制台，可以查看代码运行的时候的输出
- debugger调试，查看当前代码运行的变量等相关信息

#### 5.3、文档注释

- 用三个引号表示（块注释）
- 建议：先把参数和返回值写好，再去使用三个引号（会有自动布局）
- 写在哪？
  - 函数后面的第一行
- 在调用的时候可以通过Ctrl键+q 查看当初写的注释
- 例如

```python
def sum_num(num1, num2):
    """
	函数的主要功能
    :param num1: num1的含义
    :param num2: num2的含义
    :return: 返回值得含义
    """
```

#### 5.4、函数的参数

- 函数的参数，可以传递数据给函数内部，增加函数的通用性

  - 在函数内部，把参数当作变量使用，进行需要的数据处理
  - 函数调用的时，按照函数定义的参数顺序，把希望在函数内部梳理的数据，通过参数传递

- 形参和实参

  - 形参--->定义函数的时候设置的参数，用来代替真实数据的，在函数内部作为变量使用

  - 实参--->调用函数的时设置的真实数据，会被传递到函数内部

    - 形参的作用域：  作用在函数内部
    - 编程中应该尽量避免函数的形参和同文件的变量名同名

    ```python
    def hello(name, age = 18) 
    # age = 18 设置了age的参数，默认值为18，，，默认参数一定要位于参数列表的最后面
    
    # 指定参数、关键字参数。在调用的时候可以指定某个参数传参
    hello(name = "xiaoming", age = 22) # 指定了name的值为xiaoming,age的值为22
    ```

- 可变参数

  - *args
    - 元祖
    - 当传值的时候，除了一一对应之外，多余的全部给args

- **kwargs

  - 字典
  - 当传值的时候，如果使用指定参数的，但形参中没有的这个参数，则全部给了kwargs

- 一般情况下，可变参数写在形参的最后

#### 5.5、return返回值

- 在函数中使用return关键字可以返回结果
- 调用函数的一方，可以使用变量来接受函数的返回结果

```python
ef sum_2_num(num1, num2):
    """对两个数字的求和"""

    return num1 + num2

# 调用函数，并使用 result 变量接收计算结果
result = sum_2_num(10, 20)

print("计算结果是 %d" % result)
注意：return 表示返回，后续的代码都不会被执行
```

- 多个return
  - 一个函数中，出现了很多次的return关键字
  - 一般情况下，多个return的出现，都会在分支（if）中
- 多个返回值
  - 一个return，返回多个数据，数据之间用逗号隔开
  - 返回多个数据后，函数会自动转换（组包）成元祖进行返回
  - 接受数据的时候，可以设置一个或者对应数据个数的变量来接受
    - 如果设置一个，接受到的是元祖
    - 如果是对应数据个数的变量，系统会将元祖转换乘单个数据，分别一次接受

#### 5.6、函数的嵌套调用

- 概念：一个函数里面又调用了另外一个函数，这就是函数的嵌套调用
  - 如果函数 `func2` 中，调用了另外一个函数 `func1` ，
  - 那么执行到调用 `func1` 函数时，会先把函数 `func1` 中的任务都执行完
  - 才会回到 `func2` 中调用函数 `func1` 的位置，继续执行后续的代码

#### 5.7、全局变量和局部变量

- 全局变量 --->在函数外边定义的变量叫做全局变量
  - 作用域--->全局变量能够在所有的函数中年进行访问
- 局部变量 --->定义在函数之内
  - 作用域----> 和形参一样，函数范围之内
- 如果在函数内使用全局变量，直接用
- 如果想在函数内修改全局变量，使用global的关键字

★ 函数版本的2换0 

```python
# 有一个元组 ("789"，"123", "432" )将所有的2替换成0，按照升序排列，返回结果（"103"，"430"，"789"）  。。。不要使用字符串的replace，使用for循环一个一个找
a = ("789", "123", "432")
def hello():
    a_list = list(a)
    b_list = []
    for x in a_list:  #  x = "789"/ "123" / "432"
        z = ""
        for y in x:  #  y = 7 / 8 / 9 / 1 / 2 / 3 / 4 / 3 / 2
            if y == "2":
                y = "0"
            z = z + y  #
        b_list.append(z)
        b_list.sort()
    print(b_list)

hello()


```

#### 5.8、引用

- 如果想获取一个引用（变量）的内存地址
  - id()
- 写代码的两种形式，效果不同

```python
# 形式1
a = "hello!"
b = a
# 形式2
a = "hello!"
b = "hello!"

形式1中：a和b是一个内存地址
形式2中：a和b不是一个内存地址
>>>特殊情况
>>>数字（-5~256）
>>>字母数字下划线组成的字符串

判断内容相等用 ==
判断地址相等用 is
```

#### 5.9、可变不可变类型

- 可变 
  - 字典和列表
- 不可变
  - int、float、str、bool、tuple
- 什么是可变不可变
  - 当某个引用被修改之后，地址是否发生变化
    - 如果地址变化   不可变类型
    - 如果地址没有变化吧 可变类型
- 函数的形参的默认值，不建议传入可变类型，可能会出现问题

### 6、文件

#### 6.1、文件读写

- 作用：
  - 保存数据
- 步骤
- write  “w”  想写入文件的字符串
- read
  - read(5) 只读取5个字符串
  - read（）读取所有
  - 特点
    - 假如先读取了5个字符串，然后在read（）
    - 此时，后面的read只会读取除了前5个字符串之外的内容
- readlines
  - readlines返回一个列表，列表中的每一个元素都是一行的内容，并且每行内容会自带一个\n
- readline
  - readline 可以读取第一行的内容
  - 第一次读写就是第一行，再次运行，会读取第二行。依次类推

#### 6.2、文件和文件夹的操作

```python
import os
# rename(需要修改的文件名, 新的文件名)
os.rename("old_name", "new_name") 

os.remove("待删除的文件名")

# 创建文件夹
os.mkdir("demo")

# 获取当前目录
os.getcwd()

# 改变默认目录
os.chdir("test")  #  跳转到当前路径的test子目录中

# 获取目录列表
os.listdir()

# 删除文件夹
os.rmdir("demo") # 目录非空不能使用，使用递归删除
```

#### 6.3、文件备份案例

- 创建两个 file=open("文件"， “w/r”)
  - 一个读
  - 一个写
- 读写操作  write(read())
- 关闭两个file
- 提示成功

```python
import os
#  需要备份哪个文件
#  需要判断要备份的文件是否在对应的目录    如果在继续  如果不在
#  备份后的文件叫什么名字？
#  输入需要备份的文件
def main():
    while True:
        old_file_name = input("请输入需要备份的文件名称：")
        if old_file_name not in os.listdir():
            print("您要备份的文件不存在")
            # return
        else:
            while True:

                new_file_name = input("请输入备份后的文件名称：")
                if new_file_name in os.listdir():
                    print("你输入的文件名已经存在")
                    return
                else:

                    old_f = open(old_file_name, "r")
                    new_f = open(new_file_name, "w")
                    new_f.write(old_f.read())

                    old_f.close()
                    new_f.close()

                    print("chenggong ")
                    break
            break

if __name__ == '__main__':
    main()
```

- 利用循环创建多个文件，存放在一个文件夹中

```python
import os
#  创建新的文件夹
os.mkdir("list1")
#  改变路径
os.chdir("list1")
for i in range(1,11):
    i_str = str(i)
    filename = i_str + ".txt"
    list1 = open(filename, "w")
```



- 对已创建的文件进行批量重命名

```python
import os
os.chdir("list1")
list1 = os.listdir("./")
# print(list1)
for name in list1:
    # print(name)
    os.rename(name, "[东哥出品]-"+name)
```



### 7、递归函数

- 概念
  - 自己调用自己的函数叫做递归
- 注意点
  - 递归函数一般都需要一个条件判断来打破死循环
  - 否则会导致到达最大嵌套次数，程序报错

```python
# 利用递归进行加法运算
def step_num(num):
    if num > 1:
        return num + step_num( num - 1)
    else:
        return 1
print(step_num(100))


#  利用递归进行乘法运算，也就是阶乘
def step_num(num):
    if num > 1:
        return num * step_num(num - 1)
    else:
        return 1
print(5)
```

### 8、面向对象

#### 8.1、基本定义

- 面向对象和面向过程的含义
  - 面向对象
    - 先抽象出来，类型的概念。
    - 然后创建不同的对象，让不同的对象，做各自的事情。
    - 分工。各干各的，各有各的职责。
  - 面向过程
    - 一步一步，需要什么就写什么函数
- 面向对象的好处
  - 松耦合
  - 有利于提高团队开发的效率

#### 8.2、类和对象

- 类/类型
  - 模板
  - 抽象的概念
  - 总结具体实物特征的
  - 并不是真实的存在
  - 可以理解成不占用内存
- 对象
  - 根据模板创建出来的具体的实物
  - 不是抽象的，是具体的
  - 根据特征创建出来的实物
  - 是真实存在的
  - 占内存

#### 8.3、定义类和创建对象

- 定义类

  ```
  class 类型:
  	
  	# 属性
  	
  	# 方法
  ```

  - 命名规范 
    - 多个单词，首字母都大写，不需要任何东西连接

- 创建对象

  ```
  对象的变量名 = 类名()
  ```

  - 命名规范
    - 和变量名相同，多个单词下划线连接，都小写

#### 8.4、self

- 要在类的函数中写，表示某个对象本身。（通过哪个对象调用就是谁）
- 方法中，目前来看，第一个参数都会是self，在调用的时候，这个self忽略，因为系统会自动传值，
- self.属性名，如果之间没有过创建，会自动创建（一般情况，会写在init函数中）

#### 8.5、\__init__

- 是一个特殊的方法，只要写了，系统会自动调用，不要手动的显示调用。
- 什么时候调用？
  - 创建对象的时候调用
- 作用
  1. 在创建一个属性的时候，可以直接在init方法中写self.属性名，参考self笔记中的第三条
  2. 如果希望，使用这个类型的时候比如传入某些参数，那么可以自定义init后面的参数
     1. 调用的时候，如果不传回报错

#### 8.6、\__str__

- 是一个特殊的方法，只要写了，系统会自动调用，不要手动的显示调用。
- 什么时候调用？
  - 在print这个对象的时候会去调用
- 作用
  1. 方便调试，用的很少。
  2. 如果希望，打印的时候，输出自定义的信息，那么可以去使用这个方法。

#### 8.7、私有属性、私有方法

- 因为是私有，只能自身的类中调用，不可以在外部调用，子类也不行
- 但是，私有方法，子类是可是重写的。
- 写法
  - 属性：变量名/属性名，前面加个 __ (两个)
    - 如果是在init中定义属性，那么应该写成 self.\_\_name 而不是 \_\_self.name
  - 方法：方法名，前面加个 __ (两个)
- 当不想让外界调用或者不想让外界直接调用的时候，应该使用私有属性和方法
  - 不想让外界直接使用的情况
    - 针对私有属性，应该在类中，写一个set_xxx方法，和，get_xxx方法
    - 方法的话，可以写另外一个方法，间接调用

#### 8.8、\__del__

- 是一个特殊的方法，只要写了，系统会自动调用，不要手动的显示调用。
- 什么时候调动？
  - 当这个类型的对象，被销毁的时候，在销毁之前会调用
  - 也就是这个对象生命周期最后的一个方法
- 作用？
  - 临终遗言，如果希望在销毁之后，处理一些事情，那么使用
  - 用来保存数据

#### 8.9、继承

- 子类可以使用父类的方法

- 怎么写？

  ```
  class 子类名称(父类名称)：
  	pass
  ```

- 任何一个类型，最终都继承自object

#### 8.10、子类添加新功能

- 子类中写方法，只有子类（或者是子类的儿子或者孙子或者曾孙子等）能用，父类不能用
- 青出于蓝而胜于蓝（父类的，子类一定能用。子类的，父类不一定能用）

#### 8.11、多层继承

- 概念，一般往上继承超过两次都叫做多层继承
- 孙子能调用爹和爷爷等方法

#### 8.12、重写父类方法

- 概念？
  - “重新”写
- 怎么写？
  - 和父类的函数名称，一模一样。
  - 可能会做不同的事情，
  - 如果是子类的对象调用，以子类为准（重新写！）
- 在写代码中， \_\_init\_\_ 和 \_\_str\_\_ 和 \_\_del\_\_ 都属于重写 object 的方法

#### 8.13、调用被重写的父类方法

- 怎么调用
  - 在子类中的重写的函数中编写代码
  - super().方法名()
  - super().方法名()放置的位置，和执行顺序有关系

#### 8.14、多继承

- 一个儿子好几个爹

- 写法

  ```
  class A(B, C)
  ```

  A类继承了B和C

- A对象可以调用B和C的方法

- 如果B和C写了相同的方法，A对象，如果调用，会调用继承的第一个类的方法

#### 8.15、多态

- 多态的情况，在python是弱化的。
- 关键一句话：父类指针（引用/变量），指向子类对象
- 鸭子类型，
  - python是动态语言，当运行到代码的地方的时候，才知道真正的类型。
  - 跑之前的报错，可以忽略（能跑起来，过程不一定正确）

#### 8.16、实例属性和类属性

- 定义方式

  ```
  class A:
  	# 类属性
  	type = "dog"
  	
  	def __init__():
  		# 实例属性
  		self.name = "小明"
  ```

- 在创建对象的时候，每一个实例属性都会被创建，而类属性，只有一份。

- 什么时候用？

  - 当希望数据所有的对象都是一个值得时候，那么使用类属性
  - 希望每一个对象的属性名相同，但记录的数据不同，使用实例属性

- 理论上，类属性应该通过类来调用，和修改，实例属性，应该通过对象来调用，和修改

  - 但是，python有个特点，允许实例对象拥有类属性

#### 8.17、类方法

- 写法

  ```
  @classmethod
  def hello(cls):
  	xxxx
  ```

- 类方法一般配合类属性进行使用，cls为类本身

#### 8.18、静态方法

- 写法

  ```
  @staticmethod
  def hello():
  	xxxx
  ```

- 如果在方法中不需要是用self，那么可以把这个方法修改为静态方法（节省内存）

#### \__new__

- 什么时候会用调用
  - 一般不需要显示的调用，系统会自动的调用
  - 创建对象的时候调用（调用完成后，会调用自身的init方法）
  - 这个方法必须有返回值，返回值是创建出来的对象

#### 8.19、单例模式

- 概念

  - 无论怎么创建对象，得到的都是同一个，比如购物城
  - 思路：
    - 在new中，第一次进行创建，之后全部返回第一次创建的对象
    - 此时会发现问题，初始化（init）属性赋值有问题
      - 原因：每一次创建，调用new后都会调用init方法，所有每次初始化过得属性，都会被init的默认值覆盖
      - 解决：判断是否初始化过，如果初始化过，那么就不在初始化

- 代码

  ```
  class ShoppingCart:
  
      __instance = None
      __is_init = False
  
      def __new__(cls, *args, **kwargs):
  
          if cls.__instance is None:
              cls.__instance = super().__new__(ShoppingCart)
  
          return cls.__instance
  
      def __init__(self):
  
          if not ShoppingCart.__is_init:
              self.name = ""
  
              ShoppingCart.__is_init = True
  ```

#### 8.20、模块

- import
  - 后面跟的是“文件”或者"内容"
  - 导入完成后，如果想使用。
    - 如果导入的是文件
      - 文件.函数()
    - 如果是内容
      - 函数()
- from...import...
  - import是最终导入的东西，写代码的方式，取决于怎么导入
  - 当import之上还有路径的时候，应该通过from去写
- import...as...
  - as仅仅表示一个别名
- 制作模块
  - 如果需要写测试代码，那么应该写在模块中，
  - 需要判断\_\_name\_\_是否等于\_\_main\_\_如果等于，那么执行测试代码
- 关于\_\_name\_\_，如果运行文件中写有\_\_name\_\_，呢么\_\_name\_\_的值为\_\_main_\_
- 如果不是运行的文件，那么\_\_name\_\_的值，一定不是\_\_main\_\_

#### 8.21、异常

- 格式

  ```
  try:
      需要尝试的代码
  except ValueError as e:
      捕获ValueError错误后，执行
  except TypeError as e:
      捕获TypeError错误后，执行
  else:
      没有错误的时候执行
  finally:
      无论有没有错都会执行
  ```

- 捕获异常的时候如果去写 except Exception，表示可以捕获所有类型的异常

#### 8.22、捕获异常

- 使用 raise Exception(“错误的提示信息”)
- 如果想自定义，需要继承 Exception 类型
- 关于异常
  - 异常是可以传递的，如果某一个try有多层嵌套，如果里面没有捕获到错误，会传递给外面，以此类推，最后到没有try包裹的时候，直接报错
  - 异常也可以通过函数/方法的形式进行传递，比如 a调用b，如果b中有异常，在a中捕获也可以。

### 案例一  类的创建及模块的导入

- 类的创建及模块导入

```python
# 创建一个Animal类，name属性设置为实例属性且可传递参数，然后age属性设置为私有，初始值为0，type属性设置为类属性，值为狗。设置一个实例方法eat（），打印"狗吃骨头"，放入一个模块，名为tools。
class Animal():
    type = "狗"

    def __init__(self,name):
        self.name = name
        self.__age = 0

    def eat(self):
        print("狗吃骨头")
```

```python
#  

from tools import Animal

class Dog(Animal):
   def eat(self):
       Animal.eat(self)
       print("吃完骨头摇摇头")


dog = Dog('hello')
dog.eat()

```

### 案例二  dict、list、遍历

- 考虑以下代码，运行结果是什么？

```python
# case1
l = []
for i in range(10):
    # 每遍历一次都会生成一个value值不同的字典｛"num":1｝，然后添加到空列表
    l.append({'num':i})
print(l)

# case2
l = []
a = {'num':0}
for i in range(10):
    a['num'] = i # 每次遍历都会修改之前字典的值，知道遍历完成，添加到列表中
l.append(a)
print(l)
```

```python
# 结果
case1
# 每遍历一次生成一个新的字典添加到l列表中，最终的列表里有10个字典
[{'num': 0}, {'num': 1}, {'num': 2}, {'num': 3}, 
 {'num': 4}, {'num': 5}, {'num': 6}, {'num': 7},
 {'num': 8}, {'num': 9}]
case2
# 
[{'num': 9}]
```

### 案例三  九九乘法表

```python
# 用while循环输出九九乘法表
i = 1
while i <= 9:
    j = 1
    while j <= i:
        print("%d * %d = %d" %(j, i, i*j),end="\t")
        j += 1
    print("") # 注意每行输出完的换行
    i += 1
```

```python
# 用for循环输出九九乘法表
for i in range(1,10):
    for j in range(1,i+1):
        print("%d * %d = %d" %(j, i, i * j), end="\t" )
    print("")
```

### 案例四  办公室分配问题

- 办公室分配1.0

```python
import random
# 现有8名老师
names = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']
# 3个办公室
offices = [[],[],[]]
# 遍历老师的名字进行分配
for name in names:
    # 用随机数生成0、1、2，用来作为列表offices的索引，取出其中的办公室，进行名字随机分配
    a_index = random.randint(0, 2)
    offices[a_index].append(name)
print(offices)
# 定义变量i作为计数使用
i = 1
# 为了输出第几个办公室分别有几个人进行两次遍历
# 对存放办公室的列表进行遍历，获取其中的办公室
for a in offices:
    print("第%d个办公室有%d个人" %(i, len(a)))
    # 对随机分配完的办公室进行遍历，获取老师的名字，并输出
    for name in a:
        print("分别是：%s" % name)
    i += 1
    
# 输出结果
"""
[['A', 'D', 'E', 'H'], ['B', 'C', 'F'], ['G']]
第1个办公室有4个人
分别是：A
分别是：D
分别是：E
分别是：H
第2个办公室有3个人
分别是：B
分别是：C
分别是：F
第3个办公室有1个人
分别是：G
"""
```

- 办公室分配2.0

```python
import random
# 定义一个列表用来保存3个办公室
offices = [[], [], []]
# 定义一个列表用来存储8位老师的名字
names = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']
for name in names:  #  分配办公室
    #  获取一个随机的办公室编号
    a_index = random.randint(0,2)
    # print(a_index)
    #  将这个办公室添加进去一个教师
    offices[a_index].append(name)
print(offices)
i = 1
for a in offices:
    print("第%d个办公室有%d个人" % (i, len(a)))
    hint = "分别是："
    for name in a:
        hint = hint + (name + "、")
    hint = hint.rstrip("、")
    print(hint)
    i += 1
    
# 结果    
"""
[['B', 'C', 'H'], ['A', 'D', 'G'], ['E', 'F']]
第1个办公室有3个人
分别是：B、C、H
第2个办公室有3个人
分别是：A、D、G
第3个办公室有2个人
分别是：E、F
"""
```

- 办公室分配3.0

```python
import random
#  定义一个列表用来保存3个办公室
offices = [[], [], []]
# 定义一个列表用来存储8位老师的名字
names = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']
# 分配办公室
for name in names:
    # 获取一个随机办公室编号
    a_index = random.randint(0, 2)
    offices[a_index].append(name)
print(offices)
i = 1
for a in offices:
    print("第%d个办公室有%d个人" % (i, len(a)))
    print("分别是", end="")
    j = 0
    for name in a:
        if j == len(a) - 1:
            print(name, end="")
        else:
            print(name, end="、")
        j += 1
    #  在每输出完办公室信息之后进行换行
    print()
    i += 1
    
    
# 结果
"""
[['C', 'F'], ['A', 'E', 'G'], ['B', 'D', 'H']]
第1个办公室有2个人
分别是C、F
第2个办公室有3个人
分别是A、E、G
第3个办公室有3个人
分别是B、D、H
"""
```







